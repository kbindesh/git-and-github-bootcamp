# DOCKER NETWORKING
==========================================================================
USING BRIDGE NETWORKS
--------------------------------------------------------------------------
1) Creating Networks
   - To create a new network, use the docker network create command. 
   - You can specify the driver to use, such as bridge or host, by setting the "-d" flag. 
   - By default bridge network will be created if you omit the flag.

docker network create app-network -d bridge

2) Connecting Containers to Networks
   - You can attach new containers to a network by setting the --network flag with your docker run command.

docker run -it --rm --name bincontainer --network app-network busybox:latest

3) Next, start another container, this time without the --network flag (will go in default bridge network):
docker run -it --rm --name container2 busybox:latest

4) Now try communicating between the two containers, using their names:
# get inside container1
/ # ping container2
ping: bad address 'container2'

- The containers aren’t in the same network, so they can’t directly communicate with each other.

5) Join container2 to the same network as container1

docker network connect app-network container2

- The containers now share a network, which allows them to discover each other:
# in container1
/ # ping container2
PING container2 (172.22.0.3): 56 data bytes
64 bytes from 172.22.0.3: seq=0 ttl=64 time=4.205 ms
----------------------------------------------------------------------------
USING HOST NETWORKS
----------------------------------------------------------------------------
- You can enable host networking for a container by connecting it to the built-in host network:

docker run -d --name nginx --network host nginx:latest

- NGINX listens on port 80 by default. 
- Because the container's using a host network, you can access your NGINX server on your host's localhost:80 outside the container, even though no ports have been explicitly specified.

- To test: curl localhost:80

----------------------------------------------------------------------------
REMOVING CONTAINERS FROM THE NETWORKS
----------------------------------------------------------------------------
docker network disconnect demo-network container2

----------------------------------------------------------------------------
MANAGING NETWORKS
----------------------------------------------------------------------------
- docker network ls
- docker network rm <network-name> - To delete a network, disconnect or stop all the Docker containers that are assciated with it.
- docker network prune - automatically delete all unused networks using the network prune


----------------------------------------------------------------------------
DISABLING NETWORKS
----------------------------------------------------------------------------
- When a container's networking is disabled, it will have no connectivity available – either to other containers, or your wider network. 
- Disable networking by attaching your container to the none network.
- This lets you easily sandbox unknown services.

docker run -it --rm --network none busybox:latest



============================================================================

# Flask App Dockerfile
# Which base image to use?
FROM python:3.11-alpine

# Add metadata for the image
LABEL maintainer="KBindesh"

# Set the working directory for your app
WORKDIR /app

# Copy the app source code to working directory
COPY . .

# Install the dependencies | Run the command while building the image
RUN pip install -r requirements.txt

# Mention the port on which app container will be listening
# EXPOSE 8080

# ENTRYPOINT ["python"]

# Command to run when container starts
CMD ["python", "src/app.py"]
-------------------------------------------------------------------
docker build -t image1 .
docker run -it --name container -p 4000:8080 image1

docker run --rm -it --name test alpine /bin/sh
apk add curl
curl http://172.17.0.2:8080

-----------------------------
- By default, the docker run command does not attach the standard input stream (STDIN) of the process within the container to the host terminal. 
- However, it does connect the standard output (STDOUT) and standard error (STDERR) streams. - In other words, we’ll only see the output being printed without a way to send any input to it.
- If the main process of the container is expecting input, running it without attaching the STDIN will cause it to exit immediately.


# Running a Process With Input Prompt Without Attaching STDIN

docker run ubuntu passwd root
New password: Password change has been aborted.
passwd: Authentication token manipulation error
passwd: password unchanged


In this case, we see that the command now waits for our input.

When we pass the -i option, the docker run command attaches the input device to the main process within the container. Specifically, the input device it takes is the input device to the docker run command. Note the term “input device” here because the input device is not necessarily the terminal.

------------------------------------------------------------------
# Attaching Output Pipe to STDIN

We can also attach the output pipe to the STDIN of the process within the Docker container. For instance, let’s pipe the output of the echo command to a cat process in the container:

$ echo "This is a piped input" | docker run -i ubuntu cat

-------------------------------------------------------------------
# Allocating the Pseudo-Terminal With the -t Option

- From the official documentation, Docker states that the -t option will “allocate a pseudo-TTY” to the process inside the container. 
- TTY stands for Teletype and can be interpreted as a device that offers basic input-output. 
- The reason it’s a pseudo-TTY is that there’s no physical teletype needed, and it’s emulated using a combination of display driver and keyboard driver.

- For the sake of this article, it’s sufficient to think of a pseudo-TTY as a terminal console we’re using for running commands and reading output in Linux.

------------------------------------------------------------------------
# Missing Functionality Without the -t Option

- Without passing the -t option to docker run for the interactive mode, not all of the terminal-specific functionality will be working.

For example, most programs that prompt the user for a password will turn off the echo of the input. This allows the password to be hidden from the console.

Let’s run the passwd command with the -i option and complete the prompt:
$ docker run -i ubuntu passwd root 
New password: thisisanewpassword 
Retype new password: thisisanewpassword 
passwd: password updated successfully

Under typical usage, we know that passwd‘s password prompt does not display our password input. The way passwd achieves this is by turning off the echo option of the terminal. Since we started this process without allocating a pseudo-TTY, the echo-off functionality of the terminal is not taking effect here.

--------------------------------------------------------------------------
# Enabling Complete Terminal Functionality Using the -t Option

To enable complete terminal functionality, including the echo-off option, we can pass the -t option along with -i:

$ docker run -i -t ubuntu passwd root
New password: 
Retype new password: 
passwd: password updated successfully


Now, the echo-off option on the passwd command is working correctly under the pseudo-TTY environment.


-----------------------------------------------------------------------------
#  “Input device is not a TTY” Error

If we specify -t and then attach an output pipe to the STDIN of the container’s process, the docker run command will complain that the “input device is not a TTY”. This is because when the -t option is present, docker run will check if the input device is a TTY-like device. When it sees the input device is a pipe file, it’ll exit with an error:

$ echo "this is a pipe input" | docker run -i -t ubuntu cat
the input device is not a TTY
$ echo $?
1

------------------------------------------------------------------------------
SUMMARY


- We’ve learned that the -i option of the docker run command attaches the STDIN of the container to the host process. 
- Then, we’ve also seen how the -t option enables complete terminal functionality such as echo-off for password masking. 
- Then, we also simulated the “input device is not a TTY” error by piping the pipe files and specifying the -t option.







=========================================
DOCKER COMPOSE
=========================================
services:
  rabbitmq:
    image: rabbitmq:3.13.2-management-alpine
    container_name: 'rabbitmq'
    restart: always
    environment:
      - "RABBITMQ_DEFAULT_USER=username"
      - "RABBITMQ_DEFAULT_PASS=password"
    ports:
      - 15672:15672
      - 5672:5672
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 30s
      timeout: 10s
      retries: 5
    volumes:
      - ./rabbitmq_enabled_plugins:/etc/rabbitmq/enabled_plugins
    networks:
      - backend_services
  order-service:
    build: src/order-service
    container_name: 'order-service'
    restart: always
    ports:
      - 3000:3000
    healthcheck:
      test: ["CMD", "wget", "-O", "/dev/null", "-q", "http://order-service:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 5
    environment:
      - ORDER_QUEUE_HOSTNAME=rabbitmq
      - ORDER_QUEUE_PORT=5672
      - ORDER_QUEUE_USERNAME=username
      - ORDER_QUEUE_PASSWORD=password
      - ORDER_QUEUE_NAME=orders
      - ORDER_QUEUE_RECONNECT_LIMIT=3
    networks:
      - backend_services
    depends_on:
      rabbitmq:
        condition: service_healthy
  product-service:
    build: src/product-service
    container_name: 'product-service'
    restart: always
    ports:
      - 3002:3002
    healthcheck:
      test: ["CMD", "wget", "-O", "/dev/null", "-q", "http://product-service:3002/health"]
      interval: 30s
      timeout: 10s
      retries: 5
    environment:
      - AI_SERVICE_URL=http://ai-service:5001/
    networks:
      - backend_services
  store-front:
    build: src/store-front
    container_name: 'store-front'
    restart: always
    ports:
      - 8080:8080
    healthcheck:
      test: ["CMD", "wget", "-O", "/dev/null", "-q", "http://store-front:80/health"]
      interval: 30s
      timeout: 10s
      retries: 5
    environment:
      - VUE_APP_PRODUCT_SERVICE_URL=http://product-service:3002/
      - VUE_APP_ORDER_SERVICE_URL=http://order-service:3000/
    networks:
      - backend_services
    depends_on:
      - product-service
      - order-service
networks:
  backend_services:
    driver: bridge

-----------------------------------------
docker compose -f docker-compose-quickstart.yml up -d

docker images

docker ps

http://localhost:8080

docker compose down


