Understanding pods
=====================
You can create a pod using an imperative command as follows:  
kubectl run <pod-name> --image=<image-name:image-tag>

kubectl run nginx-pod --image=nginx:alpine

kubectl describe pod nginx-pod
--------------------------------------------------
apiVersion: v1
kind: Pod
metadata:
name: nginx
spec:
containers:
- name: nginx
image: nginx:alpine
ports:
- containerPort: 80

kubectl apply -f <your-spec>.yaml
--------------------------------------------------
Similarly, we can run a BusyBox image with a single command, such as the following:  
kubectl run busybox --rm -it --image=busybox /bin/sh

---------------------------------------------------
Understanding a multi-container pod
---------------------------------------------------
apiVersion: v1
kind: Pod
metadata:
name: multi-app-pod
labels:
app: multi-app
spec:
containers:
- name: nginx
image: nginx
ports:
- containerPort: 80
- name: busybox-sidecar
image: busybox
command: ['sh', '-c', 'while true; do sleep 3600; done;']

---------------------------------------------------
Understanding an init container
---------------------------------------------------
An init container is configured in a pod to execute before the container host starts. It is specified
inside an initContainers section, as in the following example. You can configure multiple init
containers too, which will allow each init container to complete one at a time in sequential order:

apiVersion: v1
kind: Pod
metadata:
  name: melon-pod
  labels:
    app: melonapp
spec:
  containers:
  - name: melonapp-container
    image: busybox:latest
    command: ['sh', '-c', 'echo The melonapp is running! &&
    sleep 3600']
  initContainers:
  - name: init-melonservice
    image: busybox:latest
    command: ['sh', '-c', 'until nslookup melonservice; do echo
    waiting for melonservice; sleep 2; done;']

In the case that any of the init containers fail to complete, Kubernetes will restart the pod repeatedly until
the init container succeeds.

=====================================================

=====================================================
https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/

# Pod Lifecycle phases

# Container Lifecycle phases

# Container restart policy 
=====================================================
Deploying and managing applications
=====================================================
# Replicasets
-------------
apiVersion: apps/v1
kind: ReplicaSet
metadata:
name: frontend
labels:
app: melonapp-rs
spec:
replicas: 3
selector:
matchLabels:
app: melonapp-rs
template:
metadata:
labels:
app: melonapp-rs
spec:
containers:
- name: nginx
image: nginx

kubectl get replicaset

Once the ReplicaSet is deployed, update the number of ReplicaSets by using the following command:
kubectl scale replicaset frontend --replicas=6

Alternatively, you can specify it in a YAML definition with the following command:
kubectl scale --replicas=6 -f replicas.yaml

kubectl delete replicaset frontend

=========================================
Workload scheduling
=========================================
Understanding namespaces

kubectl get namespaces

When you define a pod or any namespaced Kubernetes object, you can specify the namespace in the
YAML definition as follows:

apiVersion: v1
kind: Pod
metadata:
  name: k8s-ns-pod
  namespace: k8s-ns
  labels:
    app: k8sapp
spec:
  containers:
  - name: k8sapp-container
    image: busybox
    command: ['sh', '-c', 'echo Salut K8S! && sleep 3600']

# If you create that pod and specify the namespace that the pod belongs to, you can add the -n flag
when querying this pod using the kubectl get pods command:

kubectl get pods -n k8s-ns

# Similarly, if the pod has been created in that namespace, you can use the following command to
check it out:
kubectl describe pod k8s-ms-pod -n k8s-ns

# In the case that the pods are not in the default namespace, you don’t have to specify the namespace
option anymore. In the following example, you want to set a namespace named dev, and then use
the kubectl get command without the -n flag:

kubectl config set-context &(kubectl config current-context)
--namespace=dev

====================================================
Labels, node selectors, and annotations
====================================================
- Labels, selectors, and annotations are useful notions when it comes to workload scheduling. Labels are key-value pairs attached to Kubernetes objects that can be listed in the metadata.labels section of an object descriptor. 
- Selectors are used for identifying and selecting a group of objects using their labels. 

- See the following examples of some quality-based selectors:

kubectl get pods -l app=my-app
kubectl get pods -l environment=production

# When it comes to inequality, you can use the following:
kubectl get pods -l environment!=production

# You can start by labeling the worker nodes using the following command:
kubectl label node cloudmelonplayground env=dev

=====================================================
Understanding Job and CronJob objects
=====================================================
- Jobs can be used to reliably execute a workload and define when it completes – typically, a Job will
create one or more pods. 
- After the Job is finished, the containers will exit and the pods will enter the
Completed status.

apiVersion: batch/v1
kind: Job
  metadata:
    name: pi
spec:
  template:
    spec:
    containers:
      - name: pi
        image: perl
        command: ["perl", "-Mbignum=bpi", "-wle", "print bpi(2000)"]
    restartPolicy: Never
  backoffLimit: 4

- The backoffLimit parameter means that, if it fails 4 times, this is the limit. 
- All the Job does
the same as it is while creating a pod under the hood. 
- Although a normal pod is constantly running, when a Job is complete, it goes into the Completed status. 
- This means that the container is no longer running, so the pod still exists, but the container is complete.

------------------------------------------------------------------
# CronJobs
-------------------------------------------------------------------
CronJobs, based on the capability of a Job, add value by allowing users to execute Jobs on a schedule.
Users can use cron expressions to define a particular schedule as per their requirements.

apiVersion: batch/v1
kind: CronJob
metadata:
name: hello
spec:
schedule: "*/1 * * * *"
jobTemplate:
spec:
template:
spec:
containers:
- name: hello
image: busybox
args:
- /bin/sh
- -c
- date; echo Hello from the Kubernetes cluster
restartPolicy: OnFailure
