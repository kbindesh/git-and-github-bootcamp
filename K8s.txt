Understanding pods
=====================
You can create a pod using an imperative command as follows:  
kubectl run <pod-name> --image=<image-name:image-tag>

kubectl run nginx-pod --image=nginx:alpine

kubectl describe pod nginx-pod
--------------------------------------------------
apiVersion: v1
kind: Pod
metadata:
name: nginx
spec:
containers:
- name: nginx
image: nginx:alpine
ports:
- containerPort: 80

kubectl apply -f <your-spec>.yaml
--------------------------------------------------
Similarly, we can run a BusyBox image with a single command, such as the following:  
kubectl run busybox --rm -it --image=busybox /bin/sh

---------------------------------------------------
Understanding a multi-container pod
---------------------------------------------------
apiVersion: v1
kind: Pod
metadata:
name: multi-app-pod
labels:
app: multi-app
spec:
containers:
- name: nginx
image: nginx
ports:
- containerPort: 80
- name: busybox-sidecar
image: busybox
command: ['sh', '-c', 'while true; do sleep 3600; done;']

---------------------------------------------------
Understanding an init container
---------------------------------------------------
An init container is configured in a pod to execute before the container host starts. It is specified
inside an initContainers section, as in the following example. You can configure multiple init
containers too, which will allow each init container to complete one at a time in sequential order:

apiVersion: v1
kind: Pod
metadata:
  name: melon-pod
  labels:
    app: melonapp
spec:
  containers:
  - name: melonapp-container
    image: busybox:latest
    command: ['sh', '-c', 'echo The melonapp is running! &&
    sleep 3600']
  initContainers:
  - name: init-melonservice
    image: busybox:latest
    command: ['sh', '-c', 'until nslookup melonservice; do echo
    waiting for melonservice; sleep 2; done;']

In the case that any of the init containers fail to complete, Kubernetes will restart the pod repeatedly until
the init container succeeds.

=====================================================

=====================================================
https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/

# Pod Lifecycle phases

# Container Lifecycle phases

# Container restart policy 
=====================================================
Deploying and managing applications
=====================================================














=====================================================
Understanding Job and CronJob objects
=====================================================
- Jobs can be used to reliably execute a workload and define when it completes â€“ typically, a Job will
create one or more pods. 
- After the Job is finished, the containers will exit and the pods will enter the
Completed status.

apiVersion: batch/v1
kind: Job
  metadata:
    name: pi
spec:
  template:
    spec:
    containers:
      - name: pi
        image: perl
        command: ["perl", "-Mbignum=bpi", "-wle", "print bpi(2000)"]
    restartPolicy: Never
  backoffLimit: 4

- The backoffLimit parameter means that, if it fails 4 times, this is the limit. 
- All the Job does
the same as it is while creating a pod under the hood. 
- Although a normal pod is constantly running, when a Job is complete, it goes into the Completed status. 
- This means that the container is no longer running, so the pod still exists, but the container is complete.

------------------------------------------------------------------
# CronJobs
-------------------------------------------------------------------
CronJobs, based on the capability of a Job, add value by allowing users to execute Jobs on a schedule.
Users can use cron expressions to define a particular schedule as per their requirements.

apiVersion: batch/v1
kind: CronJob
metadata:
name: hello
spec:
schedule: "*/1 * * * *"
jobTemplate:
spec:
template:
spec:
containers:
- name: hello
image: busybox
args:
- /bin/sh
- -c
- date; echo Hello from the Kubernetes cluster
restartPolicy: OnFailure
